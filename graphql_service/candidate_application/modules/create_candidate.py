"""
This file contains object input-definitions for Candidate and Candidate's related fields
"""
import graphene
from datetime import datetime
from graphene import relay

from flask import request

from graphql_service.common.models.db import db
from graphql_service.common.models.candidate import Candidate
from graphql_service.common.models.misc import Product
from graphql_service.common.utils.datetime_utils import DatetimeUtils
from graphql_service.common.error_handling import InvalidUsage, ForbiddenError, NotFoundError, InternalServerError
from graphql_service.application import logger
from schema import CandidateType
from ..dynamodb.dynamo_actions import DynamoDB, set_empty_strings_to_null
from input_definitions import *
from ..modules.edit_candidates import add_or_edit_candidate_from_params

from db_transaction import commit_transaction


class CreateCandidate(relay.ClientIDMutation):
    """
    Class contains all input definitions for creating Candidate and Candidate's related fields.

    ok: Will be True if no errors/exceptions are detected, otherwise it will be False
    id: Candidate's unique ID generated by MySQL
    error_message: Specific error message from the API
    error_code: API specific error code. This is to help the client identify the exact error
    """
    candidate = graphene.Field(CandidateType)

    # Additional information the client may retrieve
    ok = graphene.Boolean()
    id = graphene.Int()
    error_message = graphene.String()
    http_status_code = graphene.Int()

    class Input(object):
        """
        Class contains input fields for creating candidate
        """
        # Primary data
        talent_pool_id = graphene.Int(required=True)
        first_name = graphene.String()
        middle_name = graphene.String()
        last_name = graphene.String()
        formatted_name = graphene.String()
        resume_url = graphene.String()
        objective = graphene.String()
        summary = graphene.String()
        status_id = graphene.Int()
        source_id = graphene.Int()
        source_detail = graphene.String()
        source_product_id = graphene.Int()
        title = graphene.String()

        # Secondary data
        frequency_id = graphene.String()
        addresses = graphene.List(AddressInput)
        areas_of_interest = graphene.List(AreaOfInterestInput)
        custom_fields = graphene.List(CustomFieldInput)
        educations = graphene.List(EducationInput)
        emails = graphene.List(EmailInput)
        experiences = graphene.List(ExperienceInput)
        military_services = graphene.List(MilitaryServiceInput)
        notes = graphene.List(NoteInput)
        phones = graphene.List(PhoneInput)
        photos = graphene.List(PhotoInput)
        preferred_locations = graphene.List(PreferredLocationInput)
        references = graphene.List(ReferenceInput)
        skills = graphene.List(SkillInput)
        social_networks = graphene.List(SocialNetworkInput)
        tags = graphene.List(TagInput)
        work_preferences = graphene.List(WorkPreferenceInput)

        # TODO: contact_history, openweb_id, pipelines, views

    @classmethod
    def mutate_and_get_payload(cls, args, context, info):
        """
        Function will parse candidate's information from args, validate them, and insert them into db.
        Only candidate's primary data will be added to MySQL-DB, all other data will be saved in DynamoDB
        """
        authorize_user()
        resume_url = args.get('resume_url')

        authenticated_user = request.user
        utc_datetime_now = datetime.utcnow()

        candidate_data = dict(
            user_id=authenticated_user.id,
            first_name=args.get('first_name'),
            middle_name=args.get('middle_name'),
            last_name=args.get('last_name'),
            formatted_name=args.get('formatted_name'),
            filename=resume_url,
            objective=args.get('objective'),
            summary=args.get('summary'),
            added_time=utc_datetime_now,
            candidate_status_id=args.get('status_id'),
            source_id=args.get('source_id'),
            source_detail=args.get('source_detail'),
            source_product_id=args.get('source_product_id') or Product.WEB,
            title=args.get('title')
        )

        # Insert candidate into MySQL database
        new_candidate = Candidate(**candidate_data)
        db.session.add(new_candidate)
        commit_transaction()

        # We need candidate's MySQL-generated ID as a unique identifier for DynamoDB's primary key
        candidate_id = new_candidate.id

        # Necessary data updates:
        #   - Insert MySQL generated unique ID. This will be used for DynamoDB's Candidate Primary Key
        #   - DynamoDB does not accept datetime objects; it must be converted to string
        candidate_data.update(
            id=str(candidate_id),
            added_datetime=DatetimeUtils.to_utc_str(utc_datetime_now)
        )
        del candidate_data['added_time']

        # Talent Pool Add ID is required when creating candidate
        frequency_id = args.get('frequency_id')
        talent_pool_id = args['talent_pool_id']
        addresses = args.get('addresses')
        candidate_custom_fields = args.get('custom_fields')
        educations = args.get('educations')
        emails = args.get('emails')
        experiences = args.get('experiences')
        military_services = args.get('military_services')
        notes = args.get('notes')
        phones = args.get('phones')
        photos = args.get('photos')
        preferred_locations = args.get('preferred_locations')
        references = args.get('references')
        skills = args.get('skills')
        social_networks = args.get('social_networks')
        tags = args.get('tags')
        work_preferences = args.get('work_preferences')
        try:
            candidates_validated_data = add_or_edit_candidate_from_params(
                candidate_id=candidate_id,
                talent_pool_id=talent_pool_id,
                user=authenticated_user,
                primary_data=candidate_data,
                addresses=addresses,
                candidate_custom_fields=candidate_custom_fields,
                educations=educations,
                emails=emails,
                experiences=experiences,
                military_services=military_services,
                notes=notes,
                phones=phones,
                photos=photos,
                preferred_locations=preferred_locations,
                references=references,
                skills=skills,
                social_networks=social_networks,
                tags=tags,
                frequency_id=frequency_id,
                work_preferences=work_preferences
            )
            # After all checks & validations, commit transaction before inserting candidate's data into DynamoDB
            commit_transaction()
            candidates_validated_data['is_archived'] = 0
            DynamoDB.add_candidate(set_empty_strings_to_null(candidates_validated_data))

        except (InvalidUsage, ForbiddenError, NotFoundError) as client_error:
            return CreateCandidate(ok=False, http_status_code=client_error.status_code,
                                   error_message=client_error.message)

        except InternalServerError as server_error:
            logger.exception(server_error.message)
            return CreateCandidate(ok=False, error_message=server_error.message, http_status_code=500)

        return CreateCandidate(id=candidate_id, ok=True)


def authorize_user(allow_null_user=False, allow_candidate=False):
    from graphql_service.common.error_handling import UnauthorizedError
    from graphql_service.common.models.user import User

    try:
        oauth_token = request.headers['Authorization']
    except KeyError:
        raise UnauthorizedError('You are not authorized to access this endpoint')

    json_web_token = oauth_token.replace('Bearer', '').strip()
    json_web_token = json_web_token.split('.')
    secret_key_id = json_web_token.pop()
    json_web_token = '.'.join(json_web_token)
    User.verify_jw_token(secret_key_id, json_web_token, allow_null_user, allow_candidate)
    request.oauth_token = oauth_token
