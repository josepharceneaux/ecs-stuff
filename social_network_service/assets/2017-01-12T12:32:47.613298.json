{"report": {"environment": {"Python": "2.7.9", "Platform": "Linux-4.4.0-57-generic-x86_64-with-debian-stretch-sid", "Environment": "dev"}, "tests": [{"name": "restful_api_tests/test_v1_importer.py::Test_Event_Importer::()::test_meetup_rsvp_importer_with_invalid_token", "teardown": {"duration": 0.00024008750915527344, "outcome": "passed", "name": "teardown"}, "setup": {"duration": 0.0004410743713378906, "outcome": "skipped", "name": "setup", "longrepr": "('restful_api_tests/test_v1_importer.py', 40, u'Skipped: TODO: Need to create mock endpoints for importer')"}, "run_index": 6, "duration": 0.0011222362518310547, "outcome": "skipped"}, {"name": "restful_api_tests/test_v1_events_api.py::TestResourceEvents::()::test_get_with_invalid_token", "teardown": {"duration": 0.0003590583801269531, "outcome": "passed", "name": "teardown"}, "setup": {"duration": 0.0010879039764404297, "outcome": "passed", "name": "setup"}, "run_index": 4, "call": {"duration": 0.0037131309509277344, "outcome": "failed", "name": "call", "longrepr": "self = <test_v1_events_api.TestResourceEvents object at 0x7fe864361f90>\n\n    def test_get_with_invalid_token(self):\n        \"\"\"\n            - Try to get events using invalid access_token.\n            - Expect 401 (unauthorized) in response\n            \"\"\"\n>       response = requests.get(SocialNetworkApiUrl.EVENTS, headers=auth_header('invalid_token'))\n\ntests/restful_api_tests/test_v1_events_api.py:35: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:69: in get\n    return request('get', url, params=params, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:50: in request\n    response = session.request(method=method, url=url, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:465: in request\n    resp = self.send(prep, **send_kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:573: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7fe86437f290>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7fe86437f6d0>\nverify = True, cert = None, proxies = {}\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n            :param stream: (optional) Whether to stream the request content.\n            :param timeout: (optional) How long to wait for the server to send\n                data before giving up, as a float, or a (`connect timeout, read\n                timeout <user/advanced.html#timeouts>`_) tuple.\n            :type timeout: float or tuple\n            :param verify: (optional) Whether to verify SSL certificates.\n            :param cert: (optional) Any user-provided SSL certificate to be trusted.\n            :param proxies: (optional) The proxies dictionary to apply to the request.\n            \"\"\"\n    \n        conn = self.get_connection(request.url, proxies)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request)\n    \n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n    \n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n    \n                low_conn = conn._get_conn(timeout=timeout)\n    \n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n    \n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n    \n                    low_conn.endheaders()\n    \n                    for i in request.body:\n                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\n                        low_conn.send(b'\\r\\n')\n                        low_conn.send(i)\n                        low_conn.send(b'\\r\\n')\n                    low_conn.send(b'0\\r\\n\\r\\n')\n    \n                    r = low_conn.getresponse()\n                    resp = HTTPResponse.from_httplib(\n                        r,\n                        pool=conn,\n                        connection=low_conn,\n                        preload_content=False,\n                        decode_content=False\n                    )\n                except:\n                    # If we hit any problems here, clean up the connection.\n                    # Then, reraise so that we can handle the actual exception.\n                    low_conn.close()\n                    raise\n                else:\n                    # All is well, return the connection to the pool.\n                    conn._put_conn(low_conn)\n    \n        except (ProtocolError, socket.error) as err:\n>           raise ConnectionError(err, request=request)\nE           ConnectionError: ('Connection aborted.', error(111, 'Connection refused'))\n\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/adapters.py:415: ConnectionError"}, "duration": 0.006247997283935547, "outcome": "failed"}, {"name": "restful_api_tests/test_v1_event_by_id.py::TestEventById::()::test_delete_with_invalid_token[Eventbrite]", "teardown": {"duration": 0.0002181529998779297, "outcome": "passed", "name": "teardown"}, "setup": {"duration": 0.0003998279571533203, "outcome": "skipped", "name": "setup", "longrepr": "('restful_api_tests/test_v1_event_by_id.py', 156, u'Skipped: In contact with Eventbrite support for increasing hit rate limit')"}, "run_index": 1, "duration": 0.0010178089141845703, "outcome": "skipped"}, {"name": "restful_api_tests/test_v1_events_api.py::TestResourceEvents::()::test_events_post_with_invalid_token", "teardown": {"duration": 0.0003540515899658203, "outcome": "passed", "name": "teardown"}, "setup": {"duration": 0.0009810924530029297, "outcome": "passed", "name": "setup"}, "run_index": 5, "call": {"duration": 0.0038199424743652344, "outcome": "failed", "name": "call", "longrepr": "self = <test_v1_events_api.TestResourceEvents object at 0x7fe864161c50>\n\n    def test_events_post_with_invalid_token(self):\n        \"\"\"\n            Post event using invalid token and response should be 401 (unauthorized user)\n            \"\"\"\n>       response = send_post_request(SocialNetworkApiUrl.EVENTS, {}, 'invalid_token')\n\ntests/restful_api_tests/test_v1_events_api.py:81: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/helper_functions.py:95: in send_post_request\n    headers=get_headers(access_token))\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:109: in post\n    return request('post', url, data=data, json=json, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:50: in request\n    response = session.request(method=method, url=url, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:465: in request\n    resp = self.send(prep, **send_kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:573: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7fe864161ed0>\nrequest = <PreparedRequest [POST]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7fe864459390>\nverify = True, cert = None, proxies = {}\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n            :param stream: (optional) Whether to stream the request content.\n            :param timeout: (optional) How long to wait for the server to send\n                data before giving up, as a float, or a (`connect timeout, read\n                timeout <user/advanced.html#timeouts>`_) tuple.\n            :type timeout: float or tuple\n            :param verify: (optional) Whether to verify SSL certificates.\n            :param cert: (optional) Any user-provided SSL certificate to be trusted.\n            :param proxies: (optional) The proxies dictionary to apply to the request.\n            \"\"\"\n    \n        conn = self.get_connection(request.url, proxies)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request)\n    \n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n    \n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n    \n                low_conn = conn._get_conn(timeout=timeout)\n    \n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n    \n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n    \n                    low_conn.endheaders()\n    \n                    for i in request.body:\n                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\n                        low_conn.send(b'\\r\\n')\n                        low_conn.send(i)\n                        low_conn.send(b'\\r\\n')\n                    low_conn.send(b'0\\r\\n\\r\\n')\n    \n                    r = low_conn.getresponse()\n                    resp = HTTPResponse.from_httplib(\n                        r,\n                        pool=conn,\n                        connection=low_conn,\n                        preload_content=False,\n                        decode_content=False\n                    )\n                except:\n                    # If we hit any problems here, clean up the connection.\n                    # Then, reraise so that we can handle the actual exception.\n                    low_conn.close()\n                    raise\n                else:\n                    # All is well, return the connection to the pool.\n                    conn._put_conn(low_conn)\n    \n        except (ProtocolError, socket.error) as err:\n>           raise ConnectionError(err, request=request)\nE           ConnectionError: ('Connection aborted.', error(111, 'Connection refused'))\n\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/adapters.py:415: ConnectionError"}, "duration": 0.006136178970336914, "outcome": "failed"}, {"name": "restful_api_tests/test_v1_event_by_id.py::TestEventById::()::test_put_with_invalid_token", "teardown": {"duration": 0.0003230571746826172, "outcome": "passed", "name": "teardown"}, "setup": {"duration": 0.0008559226989746094, "outcome": "passed", "name": "setup"}, "run_index": 3, "call": {"duration": 0.009441137313842773, "outcome": "failed", "name": "call", "longrepr": "self = <test_v1_event_by_id.TestEventById object at 0x7fe8642acd90>\n\n    def test_put_with_invalid_token(self):\n        \"\"\"\n            - Try to send data using invalid access_token in header and it should give 401 (unauthorized error)\n            \"\"\"\n        non_existing_id = CampaignsTestsHelpers.get_non_existing_id(Event)\n>       unauthorize_test('put', url=SocialNetworkApiUrl.EVENT % non_existing_id, data={})\n\ntests/restful_api_tests/test_v1_event_by_id.py:86: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/helper_functions.py:35: in unauthorize_test\n    response = send_request(method, url, 'invalid_token', data)\n<decorator-gen-134>:2: in send_request\n    ???\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/contracts/main.py:255: in contracts_checker\n    result = function_(*args, **kwargs)\ncommon/utils/handy_functions.py:525: in send_request\n    return request_method(url, data=data, params=params, headers=headers, verify=verify)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:122: in put\n    return request('put', url, data=data, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:50: in request\n    response = session.request(method=method, url=url, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:465: in request\n    resp = self.send(prep, **send_kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:573: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7fe8643e8250>\nrequest = <PreparedRequest [PUT]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7fe8643e8690>\nverify = True, cert = None, proxies = {}\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n            :param stream: (optional) Whether to stream the request content.\n            :param timeout: (optional) How long to wait for the server to send\n                data before giving up, as a float, or a (`connect timeout, read\n                timeout <user/advanced.html#timeouts>`_) tuple.\n            :type timeout: float or tuple\n            :param verify: (optional) Whether to verify SSL certificates.\n            :param cert: (optional) Any user-provided SSL certificate to be trusted.\n            :param proxies: (optional) The proxies dictionary to apply to the request.\n            \"\"\"\n    \n        conn = self.get_connection(request.url, proxies)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request)\n    \n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n    \n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n    \n                low_conn = conn._get_conn(timeout=timeout)\n    \n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n    \n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n    \n                    low_conn.endheaders()\n    \n                    for i in request.body:\n                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\n                        low_conn.send(b'\\r\\n')\n                        low_conn.send(i)\n                        low_conn.send(b'\\r\\n')\n                    low_conn.send(b'0\\r\\n\\r\\n')\n    \n                    r = low_conn.getresponse()\n                    resp = HTTPResponse.from_httplib(\n                        r,\n                        pool=conn,\n                        connection=low_conn,\n                        preload_content=False,\n                        decode_content=False\n                    )\n                except:\n                    # If we hit any problems here, clean up the connection.\n                    # Then, reraise so that we can handle the actual exception.\n                    low_conn.close()\n                    raise\n                else:\n                    # All is well, return the connection to the pool.\n                    conn._put_conn(low_conn)\n    \n        except (ProtocolError, socket.error) as err:\n>           raise ConnectionError(err, request=request)\nE           ConnectionError: ('Connection aborted.', error(111, 'Connection refused'))\n\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/adapters.py:415: ConnectionError"}, "duration": 0.01147603988647461, "outcome": "failed"}, {"name": "restful_api_tests/test_v1_organizer_api.py::TestOrganizers::()::test_post_with_invalid_token", "teardown": {"duration": 0.0003559589385986328, "outcome": "passed", "name": "teardown"}, "setup": {"duration": 0.0006749629974365234, "outcome": "skipped", "name": "setup", "longrepr": "('restful_api_tests/test_v1_organizer_api.py', 40, u'Skipped: In contact with Eventbrite support for increasing hit rate limit')"}, "run_index": 8, "duration": 0.0017058849334716797, "outcome": "skipped"}, {"name": "restful_api_tests/test_v1_event_by_id.py::TestEventById::()::test_get_by_id_with_invalid_token", "teardown": {"duration": 0.0002560615539550781, "outcome": "passed", "name": "teardown"}, "setup": {"duration": 0.001127004623413086, "outcome": "passed", "name": "setup"}, "run_index": 2, "call": {"duration": 0.018535852432250977, "outcome": "failed", "name": "call", "longrepr": "self = <test_v1_event_by_id.TestEventById object at 0x7fe864410850>\n\n    def test_get_by_id_with_invalid_token(self):\n        \"\"\"\n            - Get event using id and pass invalid token and it should throw exception 401 un-authorize\n            - Also make sure if event is present in response data\n            \"\"\"\n        non_existing_id = CampaignsTestsHelpers.get_non_existing_id(Event)\n>       response = unauthorize_test(url=SocialNetworkApiUrl.EVENT % non_existing_id, method='get')\n\ntests/restful_api_tests/test_v1_event_by_id.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/helper_functions.py:35: in unauthorize_test\n    response = send_request(method, url, 'invalid_token', data)\n<decorator-gen-134>:2: in send_request\n    ???\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/contracts/main.py:255: in contracts_checker\n    result = function_(*args, **kwargs)\ncommon/utils/handy_functions.py:525: in send_request\n    return request_method(url, data=data, params=params, headers=headers, verify=verify)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:69: in get\n    return request('get', url, params=params, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:50: in request\n    response = session.request(method=method, url=url, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:465: in request\n    resp = self.send(prep, **send_kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:573: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7fe86442d9d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7fe86443a510>\nverify = True, cert = None, proxies = {}\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n            :param stream: (optional) Whether to stream the request content.\n            :param timeout: (optional) How long to wait for the server to send\n                data before giving up, as a float, or a (`connect timeout, read\n                timeout <user/advanced.html#timeouts>`_) tuple.\n            :type timeout: float or tuple\n            :param verify: (optional) Whether to verify SSL certificates.\n            :param cert: (optional) Any user-provided SSL certificate to be trusted.\n            :param proxies: (optional) The proxies dictionary to apply to the request.\n            \"\"\"\n    \n        conn = self.get_connection(request.url, proxies)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request)\n    \n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n    \n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n    \n                low_conn = conn._get_conn(timeout=timeout)\n    \n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n    \n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n    \n                    low_conn.endheaders()\n    \n                    for i in request.body:\n                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\n                        low_conn.send(b'\\r\\n')\n                        low_conn.send(i)\n                        low_conn.send(b'\\r\\n')\n                    low_conn.send(b'0\\r\\n\\r\\n')\n    \n                    r = low_conn.getresponse()\n                    resp = HTTPResponse.from_httplib(\n                        r,\n                        pool=conn,\n                        connection=low_conn,\n                        preload_content=False,\n                        decode_content=False\n                    )\n                except:\n                    # If we hit any problems here, clean up the connection.\n                    # Then, reraise so that we can handle the actual exception.\n                    low_conn.close()\n                    raise\n                else:\n                    # All is well, return the connection to the pool.\n                    conn._put_conn(low_conn)\n    \n        except (ProtocolError, socket.error) as err:\n>           raise ConnectionError(err, request=request)\nE           ConnectionError: ('Connection aborted.', error(111, 'Connection refused'))\n\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/adapters.py:415: ConnectionError"}, "duration": 0.021045923233032227, "outcome": "failed"}, {"name": "restful_api_tests/test_v1_organizer_api.py::TestOrganizers::()::test_get_with_invalid_token", "teardown": {"duration": 0.0003561973571777344, "outcome": "passed", "name": "teardown"}, "setup": {"duration": 0.0007348060607910156, "outcome": "skipped", "name": "setup", "longrepr": "('restful_api_tests/test_v1_organizer_api.py', 19, u'Skipped: In contact with Eventbrite support for increasing hit rate limit')"}, "run_index": 7, "duration": 0.0018258094787597656, "outcome": "skipped"}, {"name": "restful_api_tests/test_v1_venue_api.py::TestVenues::()::test_post_with_invalid_token", "teardown": {"duration": 0.0003180503845214844, "outcome": "passed", "name": "teardown"}, "setup": {"duration": 0.0011599063873291016, "outcome": "passed", "name": "setup"}, "run_index": 11, "call": {"duration": 0.003815889358520508, "outcome": "failed", "name": "call", "longrepr": "self = <test_v1_venue_api.TestVenues object at 0x7fe8640e0510>\n\n    def test_post_with_invalid_token(self):\n        \"\"\"\n            Send POST request to create venue endpoint with invalid token in header and response should be 401 unauthorized\n            \"\"\"\n>       response = requests.post(SocialNetworkApiUrl.VENUES, headers=auth_header('invalid_token'))\n\ntests/restful_api_tests/test_v1_venue_api.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:109: in post\n    return request('post', url, data=data, json=json, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:50: in request\n    response = session.request(method=method, url=url, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:465: in request\n    resp = self.send(prep, **send_kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:573: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7fe8640e07d0>\nrequest = <PreparedRequest [POST]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7fe8640e0c10>\nverify = True, cert = None, proxies = {}\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n            :param stream: (optional) Whether to stream the request content.\n            :param timeout: (optional) How long to wait for the server to send\n                data before giving up, as a float, or a (`connect timeout, read\n                timeout <user/advanced.html#timeouts>`_) tuple.\n            :type timeout: float or tuple\n            :param verify: (optional) Whether to verify SSL certificates.\n            :param cert: (optional) Any user-provided SSL certificate to be trusted.\n            :param proxies: (optional) The proxies dictionary to apply to the request.\n            \"\"\"\n    \n        conn = self.get_connection(request.url, proxies)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request)\n    \n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n    \n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n    \n                low_conn = conn._get_conn(timeout=timeout)\n    \n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n    \n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n    \n                    low_conn.endheaders()\n    \n                    for i in request.body:\n                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\n                        low_conn.send(b'\\r\\n')\n                        low_conn.send(i)\n                        low_conn.send(b'\\r\\n')\n                    low_conn.send(b'0\\r\\n\\r\\n')\n    \n                    r = low_conn.getresponse()\n                    resp = HTTPResponse.from_httplib(\n                        r,\n                        pool=conn,\n                        connection=low_conn,\n                        preload_content=False,\n                        decode_content=False\n                    )\n                except:\n                    # If we hit any problems here, clean up the connection.\n                    # Then, reraise so that we can handle the actual exception.\n                    low_conn.close()\n                    raise\n                else:\n                    # All is well, return the connection to the pool.\n                    conn._put_conn(low_conn)\n    \n        except (ProtocolError, socket.error) as err:\n>           raise ConnectionError(err, request=request)\nE           ConnectionError: ('Connection aborted.', error(111, 'Connection refused'))\n\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/adapters.py:415: ConnectionError"}, "duration": 0.006453752517700195, "outcome": "failed"}, {"name": "restful_api_tests/test_v1_organizer_api.py::TestOrganizers::()::test_delete_with_invalid_token", "teardown": {"duration": 0.0003559589385986328, "outcome": "passed", "name": "teardown"}, "setup": {"duration": 0.0008599758148193359, "outcome": "skipped", "name": "setup", "longrepr": "('restful_api_tests/test_v1_organizer_api.py', 147, u'Skipped: In contact with Eventbrite support for increasing hit rate limit')"}, "run_index": 9, "duration": 0.0020759105682373047, "outcome": "skipped"}, {"name": "restful_api_tests/test_v1_venue_api.py::TestVenues::()::test_get_with_invalid_token", "teardown": {"duration": 0.00034689903259277344, "outcome": "passed", "name": "teardown"}, "setup": {"duration": 0.0018241405487060547, "outcome": "passed", "name": "setup"}, "run_index": 10, "call": {"duration": 0.006015777587890625, "outcome": "failed", "name": "call", "longrepr": "self = <test_v1_venue_api.TestVenues object at 0x7fe8642be490>\n\n    def test_get_with_invalid_token(self):\n        \"\"\"\n            Send POST request with invalid_token in header and response should be 401 (unauthorized)\n            \"\"\"\n>       response = requests.post(SocialNetworkApiUrl.VENUES, headers=auth_header('invalid_token'))\n\ntests/restful_api_tests/test_v1_venue_api.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:109: in post\n    return request('post', url, data=data, json=json, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:50: in request\n    response = session.request(method=method, url=url, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:465: in request\n    resp = self.send(prep, **send_kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:573: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7fe864479bd0>\nrequest = <PreparedRequest [POST]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7fe864294410>\nverify = True, cert = None, proxies = {}\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n            :param stream: (optional) Whether to stream the request content.\n            :param timeout: (optional) How long to wait for the server to send\n                data before giving up, as a float, or a (`connect timeout, read\n                timeout <user/advanced.html#timeouts>`_) tuple.\n            :type timeout: float or tuple\n            :param verify: (optional) Whether to verify SSL certificates.\n            :param cert: (optional) Any user-provided SSL certificate to be trusted.\n            :param proxies: (optional) The proxies dictionary to apply to the request.\n            \"\"\"\n    \n        conn = self.get_connection(request.url, proxies)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request)\n    \n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n    \n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n    \n                low_conn = conn._get_conn(timeout=timeout)\n    \n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n    \n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n    \n                    low_conn.endheaders()\n    \n                    for i in request.body:\n                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\n                        low_conn.send(b'\\r\\n')\n                        low_conn.send(i)\n                        low_conn.send(b'\\r\\n')\n                    low_conn.send(b'0\\r\\n\\r\\n')\n    \n                    r = low_conn.getresponse()\n                    resp = HTTPResponse.from_httplib(\n                        r,\n                        pool=conn,\n                        connection=low_conn,\n                        preload_content=False,\n                        decode_content=False\n                    )\n                except:\n                    # If we hit any problems here, clean up the connection.\n                    # Then, reraise so that we can handle the actual exception.\n                    low_conn.close()\n                    raise\n                else:\n                    # All is well, return the connection to the pool.\n                    conn._put_conn(low_conn)\n    \n        except (ProtocolError, socket.error) as err:\n>           raise ConnectionError(err, request=request)\nE           ConnectionError: ('Connection aborted.', error(111, 'Connection refused'))\n\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/adapters.py:415: ConnectionError"}, "duration": 0.010010957717895508, "outcome": "failed"}, {"name": "restful_api_tests/test_v1_event_by_id.py::TestEventById::()::test_delete_with_invalid_token[Meetup]", "teardown": {"duration": 0.00031304359436035156, "outcome": "passed", "name": "teardown"}, "setup": {"duration": 3.681514024734497, "outcome": "error", "stdout": "('Test Data Response: ', '{\"domains\": [{\"organization_id\": \"\", \"name\": \"test_domain_first1484224369.01gCZHdk9FBI\", \"default_tracking_code\": \"\", \"is_fair_check_on\": false, \"is_active\": true, \"settings_json\": \"\", \"default_from_name\": \"\", \"usage_limitation\": \"\", \"dice_company_id\": \"\", \"expiration\": \"\", \"added_time\": \"2017-01-12 12:32:49\", \"updated_time\": \"2017-01-12 12:32:49\", \"is_disabled\": 0, \"id\": 221, \"default_culture_id\": 1}, {\"organization_id\": \"\", \"name\": \"test_domain_second1484224369.01gCZHdk9FBI\", \"default_tracking_code\": \"\", \"is_fair_check_on\": false, \"is_active\": true, \"settings_json\": \"\", \"default_from_name\": \"\", \"usage_limitation\": \"\", \"dice_company_id\": \"\", \"expiration\": \"\", \"added_time\": \"2017-01-12 12:32:49\", \"updated_time\": \"2017-01-12 12:32:49\", \"is_disabled\": 0, \"id\": 222, \"default_culture_id\": 1}], \"groups_ids\": [214, 215], \"client\": {\"client_secret\": \"acl63WocVbzGvWucjhskD5WNpdFtjc6BzxuOgzx4lYTQLcWKqoXfdZ2\", \"client_name\": \"test_client\", \"client_id\": \"ty5hfM9yoRkLcP2MRLLs3qtkaItCNcQUFahIfeic\"}, \"users\": [{\"id\": 314, \"user_group_id\": 214, \"domain_id\": 221, \"email\": \"1484224369.01gCZHdk9FBItest_email@test.com\", \"role_id\": 5}, {\"id\": 315, \"user_group_id\": 214, \"domain_id\": 221, \"email\": \"1484224369.01gCZHdk9FBItest_email_same_domain@test.com\", \"role_id\": 5}, {\"id\": 316, \"user_group_id\": 215, \"domain_id\": 222, \"email\": \"1484224369.01gCZHdk9FBItest_email_second@test.com\", \"role_id\": 5}], \"tokens\": [{\"user_id\": 314, \"access_token\": \"iEGFog1f7Qv5rC5ivROnd3JCIaqgF7BgpPTMVu07VED2paU5L78VLY4XiJev\", \"expires\": \"2020-12-31 00:00:00\", \"token_type\": \"Bearer\", \"client_id\": \"ty5hfM9yoRkLcP2MRLLs3qtkaItCNcQUFahIfeic\", \"_scopes\": \"\", \"id\": 319, \"refresh_token\": \"a8qVtvN6XxDlQySRN48aW7apcxBX6QYT9CwZPlEOpXRVJRYXaX0hpJwIz4Hj\"}, {\"user_id\": 315, \"access_token\": \"xygE6hkuBgAq0iHOsvcopVImJF7ZAOhUQW1gTvy2B20mcXLd23pyWpO1yt0u\", \"expires\": \"2020-12-31 00:00:00\", \"token_type\": \"Bearer\", \"client_id\": \"ty5hfM9yoRkLcP2MRLLs3qtkaItCNcQUFahIfeic\", \"_scopes\": \"\", \"id\": 320, \"refresh_token\": \"8gIW0r33ihynlEXadQjiWjSpf20XJZ9TGAUNBIZFkEiqvzhXplgdtxMzvU3u\"}, {\"user_id\": 316, \"access_token\": \"4zmlMBvI8GoATIZ5jgJzFWXDwGanNYC41mKoi28pjRobf9S3sn8tBe1BbcTD\", \"expires\": \"2020-12-31 00:00:00\", \"token_type\": \"Bearer\", \"client_id\": \"ty5hfM9yoRkLcP2MRLLs3qtkaItCNcQUFahIfeic\", \"_scopes\": \"\", \"id\": 321, \"refresh_token\": \"JFXjo6EP3ZqFk1qsq9Km7CAj4IdbXExMD7i5EVz16tVAAJ1w590Hpel8KEpx\"}]}\\n', 200)\n", "name": "setup", "longrepr": "request = <SubRequest 'event_in_db' for <Function 'test_delete_with_invalid_token[Meetup]'>>\n\n    @pytest.fixture(scope=\"session\", params=VENDORS)\n    def event_in_db(request):\n        \"\"\"\n        This fixture creates an event on vendor basis and returns it.\n        e.g. In case of Eventbrite, it will return fixture named as \"eventbrite_event\"\n        \"\"\"\n>       return deepcopy(request.getfuncargvalue(\"{}_event\".format(request.param.lower())))\n\ncommon/campaign_services/tests/conftest.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmeetup = {'id': 27L}\nuser_first = {'domain_id': 221, 'email': '1484224369.01gCZHdk9FBItest_email@test.com', 'id': 314, 'role_id': 5, ...}\ntoken_first = 'iEGFog1f7Qv5rC5ivROnd3JCIaqgF7BgpPTMVu07VED2paU5L78VLY4XiJev'\ntest_meetup_credentials = <social_network_service.common.models.user.UserSocialNetworkCredential object at 0x7fe864d2fa90>\n\n    @pytest.fixture(scope=\"session\")\n    def meetup_venue(meetup, user_first, token_first, test_meetup_credentials):\n        \"\"\"\n        This fixture returns meetup venue in getTalent database\n        \"\"\"\n        social_network_id = meetup['id']\n        venue = {\n            \"social_network_id\": social_network_id,\n            \"user_id\": user_first['id'],\n            \"zip_code\": \"95014\",\n            \"group_url_name\": 'Python-Learning-Meetup',\n            \"address_line_2\": \"\",\n            \"address_line_1\": \"Infinite Loop\",\n            \"latitude\": 0,\n            \"longitude\": 0,\n            \"state\": \"CA\",\n            \"city\": \"Cupertino\",\n            \"country\": \"us\"\n        }\n    \n        response_post = send_request('POST', SocialNetworkApiUrl.VENUES, access_token=token_first, data=venue)\n    \n        data = response_post.json()\n        if response_post.status_code == codes.bad:\n            data = data['error']\n    \n>       assert response_post.status_code == codes.created or response_post.status_code == codes.bad, response_post.text\nE       AssertionError: {\nE         \"error\": {\nE           \"code\": 4066, \nE           \"message\": \"Access token has expired for Meetup\"\nE         }\nE       }\n\ncommon/campaign_services/tests/conftest.py:84: AssertionError"}, "run_index": 0, "duration": 7.3633410930633545, "outcome": "error"}, {"name": "restful_api_tests/test_v1_venue_api.py::TestVenues::()::test_delete_with_invalid_token", "teardown": {"duration": 0.0007450580596923828, "outcome": "passed", "name": "teardown"}, "setup": {"duration": 0.0009200572967529297, "outcome": "passed", "name": "setup"}, "run_index": 12, "call": {"duration": 0.004286050796508789, "outcome": "failed", "name": "call", "longrepr": "self = <test_v1_venue_api.TestVenues object at 0x7fe8641d7190>\n\n    def test_delete_with_invalid_token(self):\n        \"\"\"\n            Send DELETE request to delete venues endpoint using invalid token in header. response should be\n            unauthorized (401)\n            \"\"\"\n        response = requests.delete(SocialNetworkApiUrl.VENUES, data=json.dumps({'ids': []}),\n>                                  headers=get_headers('invalid_token'))\n\ntests/restful_api_tests/test_v1_venue_api.py:95: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:147: in delete\n    return request('delete', url, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/api.py:50: in request\n    response = session.request(method=method, url=url, **kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:465: in request\n    resp = self.send(prep, **send_kwargs)\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/sessions.py:573: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7fe8641d7490>\nrequest = <PreparedRequest [DELETE]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7fe8641d78d0>\nverify = True, cert = None, proxies = {}\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n            :param stream: (optional) Whether to stream the request content.\n            :param timeout: (optional) How long to wait for the server to send\n                data before giving up, as a float, or a (`connect timeout, read\n                timeout <user/advanced.html#timeouts>`_) tuple.\n            :type timeout: float or tuple\n            :param verify: (optional) Whether to verify SSL certificates.\n            :param cert: (optional) Any user-provided SSL certificate to be trusted.\n            :param proxies: (optional) The proxies dictionary to apply to the request.\n            \"\"\"\n    \n        conn = self.get_connection(request.url, proxies)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request)\n    \n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n    \n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n    \n                low_conn = conn._get_conn(timeout=timeout)\n    \n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n    \n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n    \n                    low_conn.endheaders()\n    \n                    for i in request.body:\n                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\n                        low_conn.send(b'\\r\\n')\n                        low_conn.send(i)\n                        low_conn.send(b'\\r\\n')\n                    low_conn.send(b'0\\r\\n\\r\\n')\n    \n                    r = low_conn.getresponse()\n                    resp = HTTPResponse.from_httplib(\n                        r,\n                        pool=conn,\n                        connection=low_conn,\n                        preload_content=False,\n                        decode_content=False\n                    )\n                except:\n                    # If we hit any problems here, clean up the connection.\n                    # Then, reraise so that we can handle the actual exception.\n                    low_conn.close()\n                    raise\n                else:\n                    # All is well, return the connection to the pool.\n                    conn._put_conn(low_conn)\n    \n        except (ProtocolError, socket.error) as err:\n>           raise ConnectionError(err, request=request)\nE           ConnectionError: ('Connection aborted.', error(111, 'Connection refused'))\n\n../../../.pyenv/versions/2.7.9/lib/python2.7/site-packages/requests/adapters.py:415: ConnectionError"}, "duration": 0.006871223449707031, "outcome": "failed"}], "created_at": "2017-01-12 17:32:55.053460", "summary": {"duration": 6.369700193405151, "failed": 7, "skipped": 5, "num_tests": 13, "error": 1}}}